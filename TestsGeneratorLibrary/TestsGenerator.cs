using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGeneratorLibrary
{
    public class TestsGenerator
    {
        private static List<UsingDirectiveSyntax> _usingsList = new List<UsingDirectiveSyntax>
        {
            UsingDirective(IdentifierName("System")),
            UsingDirective(IdentifierName("System.Collections.Generic")),
            UsingDirective(IdentifierName("System.Linq")),
            UsingDirective(IdentifierName("System.Text")),
            UsingDirective(IdentifierName("NUnit.Framework"))
        };

        private SyntaxList<UsingDirectiveSyntax> _usingsSyntaxList = new SyntaxList<UsingDirectiveSyntax>(_usingsList);

        public List<OutputFileInfo> CreateTests(string sourseCode)
        {
            List<ClassInfo> classInfos = GetClassesInfo(sourseCode);

            List < OutputFileInfo > outputInfos = new List<OutputFileInfo>();
            foreach (ClassInfo classInfo in classInfos)
            {
                outputInfos.Add(new OutputFileInfo(classInfo.Name + "Tests", CreateTestClass(classInfo)));
            }

            return outputInfos;
        }

        private string CreateTestClass(ClassInfo classInfo)
        {
            ClassDeclarationSyntax classSyntax = ClassDeclaration(classInfo.Name + "Tests")
                .AddModifiers(Token(SyntaxKind.PublicKeyword))
                .WithMembers(new SyntaxList<MemberDeclarationSyntax>(CreateTestMethods(classInfo)))
                .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestFixture"))))));

            NamespaceDeclarationSyntax namespaceSyntax = NamespaceDeclaration(IdentifierName(classInfo.NamespaceName + ".Tests"))
                .WithMembers(new SyntaxList<MemberDeclarationSyntax>(classSyntax));

            var tempUsingsSyntaxList = _usingsSyntaxList.Add(UsingDirective(IdentifierName(classInfo.NamespaceName)));

            return CompilationUnit()
                    .WithUsings(tempUsingsSyntaxList)
                    .AddMembers(namespaceSyntax).NormalizeWhitespace().ToFullString();
        }

        private List<MemberDeclarationSyntax> CreateTestMethods(ClassInfo classInfo)
        {
            List<MemberDeclarationSyntax> testMethods = new List<MemberDeclarationSyntax>();

            ArgumentListSyntax argumentList = ArgumentList(SingletonSeparatedList(Argument(LiteralExpression(
                SyntaxKind.StringLiteralExpression, Literal("autogenerated")))));

            var body = ExpressionStatement(InvocationExpression(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,IdentifierName("Assert"), IdentifierName("Fail")))
                .WithArgumentList(argumentList));

            foreach(var method in classInfo.MethodNames)
            {
                MethodDeclarationSyntax testMethod = MethodDeclaration(PredefinedType(
                        Token(SyntaxKind.VoidKeyword)), method + "Test")
                    .AddModifiers(Token(SyntaxKind.PublicKeyword))
                    .WithAttributeLists(SingletonList(AttributeList(
                        SingletonSeparatedList(Attribute(IdentifierName("Test"))))))
                    .WithBody(Block(body));

                testMethods.Add(testMethod);
            }

            return testMethods;
        }

        private List<ClassInfo> GetClassesInfo(string code)
        {
            SyntaxNode root = CSharpSyntaxTree.ParseText(code).GetRoot();
            var classInfoList = new List<ClassInfo>();

            IEnumerable<NamespaceDeclarationSyntax> namespacies = root
            .DescendantNodes()
            .OfType<NamespaceDeclarationSyntax>();            

            foreach (var ns in namespacies)
            {
                string namespaceName = ns.Name.ToString();

                IEnumerable<ClassDeclarationSyntax> classes = ns
                .DescendantNodes()
                .OfType<ClassDeclarationSyntax>()
                .Where(m => m.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PublicKeyword)));

                foreach (var cl in classes)
                {
                    IEnumerable<MethodDeclarationSyntax> methods = cl
                    .DescendantNodes()
                    .OfType<MethodDeclarationSyntax>()
                    .Where(m => m.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PublicKeyword)));

                    List<string> methodsName = methods.Select(method => method.Identifier.Text).ToList();

                    var duplicateMethods = methodsName.GroupBy(x => x)
                                            .Where(g => g.Count() > 1)
                                            .ToDictionary(x => x.Key, x => x.Count());

                    foreach (var duplicate in duplicateMethods)
                    {
                        for (int i = 1; i <= duplicate.Value; i++ )
                        {
                            methodsName[methodsName.FindIndex(name => name == duplicate.Key)] += "_" + i;
                        }
                        
                    }

                    classInfoList.Add(new ClassInfo(cl.Identifier.Text, namespaceName, methodsName));
                }
            }

            return classInfoList;
        }
    }
}